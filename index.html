<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sterownik Wiatrowy – MQTT</title>

  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

  <style>
    :root{ --card-w:1100px; }

    /* ===== BODY ===== */
    body{
      font-family: Arial, sans-serif;
      padding:20px;
      color:#111;
      min-height:100vh;
      margin:0;
      background:#000;
    }

    /* ===== VIDEO BACKGROUND ===== */
    .bg{
      position: fixed;
      inset: 0;
      z-index: -2;
      overflow: hidden;
      background: url("assets/wiatrak.webp") center top / cover no-repeat;
    }
    .bg-video{
      width:100%;
      height:100%;
      object-fit:cover;
      object-position:center top;
      display:block;
    }
    @media (prefers-reduced-motion: reduce){
      .bg-video{ display:none; }
    }

    /* ===== OVERLAY ===== */
    .ui-overlay{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background: linear-gradient(
        to bottom,
        rgba(255,255,255,0.00) 0%,
        rgba(255,255,255,0.08) 35%,
        rgba(255,255,255,0.18) 100%
      );
    }

    /* ===== UI ===== */
    #app{ position: relative; z-index: 1; }

    h1{
      text-align:center;
      margin:8px 0 14px;
      text-shadow:0 1px 0 rgba(255,255,255,0.6);
    }

    #status{
      max-width:var(--card-w);
      margin:0.5rem auto 1rem;
      font-size:12px;
      text-align:center;
      color:#111;
      text-shadow:0 1px 0 rgba(255,255,255,0.6);
      line-height: 1.35;
    }
    #status b{ font-weight:700; }

    .grid{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(260px, 1fr));
      gap:12px;
      max-width:var(--card-w);
      margin:0 auto;
    }

    .card{
      background: rgba(255,255,255,0.92);
      padding:15px;
      border-radius:14px;
      box-shadow:0 10px 22px rgba(0,0,0,0.14);
      backdrop-filter: blur(2px);
    }

    .label{ font-weight:bold; }
    .value{ float:right; font-weight:700; }
    .unit{ margin-left:4px; color:#666; font-weight:500 }

    /* Karta wiatru: kolorowana */
    .wind-card{ border: 1px solid rgba(0,0,0,0.06); }
    .wind-card.good   { background: rgba(232,245,233,0.92); }
    .wind-card.mid    { background: rgba(255,249,196,0.92); }
    .wind-card.high   { background: rgba(255,224,178,0.92); }
    .wind-card.danger { background: rgba(255,205,210,0.92); }

    /* małe dopracowanie: żeby wartości nie "skakały" szerokością */
    .value{ min-width: 90px; text-align:right; display:inline-block; }
  </style>
</head>

<body>

  <!-- ===== VIDEO BACKGROUND ===== -->
  <div class="bg" aria-hidden="true">
    <video class="bg-video"
           autoplay
           muted
           loop
           playsinline
           preload="auto"
           poster="assets/wiatrak.webp">
      <source src="assets/wiatrak.mp4" type="video/mp4">
    </video>
  </div>

  <div class="ui-overlay" aria-hidden="true"></div>

  <div id="app">
    <h1>Sterownik Wiatrowy M6</h1>
    <div id="status">
      Status MQTT: <b id="mqttStatus">inicjalizacja…</b>
      <span id="diag"></span>
    </div>

    <div class="grid">
      <div class="card">
        <span class="label">Wiatrak (energia)</span>
        <span class="value"><span id="kwh">—</span><span class="unit">kWh</span></span>
      </div>

      <div class="card">
        <span class="label">Moc ładowania</span>
        <span class="value"><span id="power">—</span><span class="unit">W</span></span>
      </div>

      <div class="card">
        <span class="label">Naładowanie baterii</span>
        <span class="value"><span id="soc">—</span><span class="unit">%</span></span>
      </div>

      <div class="card">
        <span class="label">Napięcie baterii</span>
        <span class="value"><span id="bat_v">—</span><span class="unit">V</span></span>
      </div>

      <div class="card">
        <span class="label">Prąd ładowania</span>
        <span class="value"><span id="bat_a">—</span><span class="unit">A</span></span>
      </div>

      <div class="card wind-card" id="windCard">
        <span class="label">Prędkość wiatru</span>
        <span class="value"><span id="wind">—</span><span class="unit">m/s</span></span>
      </div>

      <div class="card">
        <span class="label">Hamulec turbiny</span>
        <span class="value" id="brake">—</span>
      </div>

      <div class="card">
        <span class="label">Wyjście LOAD</span>
        <span class="value" id="loadState">—</span>
      </div>
    </div>
  </div>

<script>
(() => {
  const PREFIX = "sterownik_wiatrowy";
  const WS_URL = "wss://broker.hivemq.com:8884/mqtt";
  const TOPIC_WIND_PUBLIC = `${PREFIX}/public/wind_speed`;

  // progi (m/s) – do kolorowania karty wiatru
  const MID_AT  = 3.0;
  const HIGH_AT = 8.0;
  const DANG_AT = 15.0;

  // watchdog: ile sekund bez żadnej wiadomości uznajemy za "zawieszenie"
  const WATCHDOG_IDLE_SEC = 20;

  function parseNumber(val){
    const m = String(val).match(/-?\d+(?:[.,]\d+)?/);
    return m ? parseFloat(m[0].replace(',', '.')) : NaN;
  }
  function fmt1dec(n){
    if(isNaN(n)) return "—";
    return (Math.round(n*10)/10).toFixed(1).replace('.',',');
  }

  const els = {
    kwh:  document.getElementById('kwh'),
    power:document.getElementById('power'),
    soc:  document.getElementById('soc'),
    bat_v:document.getElementById('bat_v'),
    bat_a:document.getElementById('bat_a'),
    wind: document.getElementById('wind'),
    windCard: document.getElementById('windCard'),
    brake:document.getElementById('brake'),
    loadState:document.getElementById('loadState'),
    mqttStatus:document.getElementById('mqttStatus'),
    diag:document.getElementById('diag'),
  };

  function setWindCardClass(w){
    els.windCard.classList.remove('good','mid','high','danger');
    if(w == null || isNaN(w)) return;
    if(w < MID_AT) els.windCard.classList.add('good');
    else if(w < HIGH_AT) els.windCard.classList.add('mid');
    else if(w < DANG_AT) els.windCard.classList.add('high');
    else els.windCard.classList.add('danger');
  }

  // Twoje topic-y (z alternatywami od "krzaczków")
  const TOPICS = {
    kwh:   [`${PREFIX}/sensor/wiatrak_kwh/state`],
    power: [`${PREFIX}/sensor/moc__adowania/state`, `${PREFIX}/sensor/moc___adowania/state`],
    soc:   [`${PREFIX}/sensor/procent_na__adowania_baterii/state`, `${PREFIX}/sensor/procent_na_adowania_baterii/state`],
    bat_v: [`${PREFIX}/sensor/napi_cie_baterii/state`, `${PREFIX}/sensor/napi__cie_baterii/state`],
    bat_a: [`${PREFIX}/sensor/pr_d__adowania/state`, `${PREFIX}/sensor/pr__d___adowania/state`],
    brake_state: [`${PREFIX}/switch/hamulec_turbiny/state`],
    load_state:  [`${PREFIX}/switch/wyjscie_load/state`, `${PREFIX}/switch/wyj__cie_load/state`],
  };

  const allTopics = [...new Set(Object.values(TOPICS).flat().concat([TOPIC_WIND_PUBLIC]))];

  const matchTopic = (incoming, candidates) =>
    (Array.isArray(candidates)?candidates:[candidates]).includes(incoming);

  const noteNum = (val) => {
    const v = parseNumber(val);
    return isNaN(v) ? null : v;
  };

  let client = null;
  let lastMsgAt = 0;
  let msgCount = 0;
  let reconnectCount = 0;

  function renderDiag(extra=""){
    const last = lastMsgAt ? new Date(lastMsgAt).toLocaleTimeString() : "—";
    els.diag.innerHTML =
      `<span> | odebrano: <b>${msgCount}</b></span>` +
      `<span> | ostatnio: <b>${last}</b></span>` +
      `<span> | reconnect: <b>${reconnectCount}</b></span>` +
      (extra ? `<span> | ${extra}</span>` : ``);
  }

  function subscribeAll(){
    if(!client) return;
    allTopics.forEach(t => client.subscribe(t, {qos:0}));
  }

  function connect(){
    if(client){
      try { client.end(true); } catch(_) {}
      client = null;
    }

    client = mqtt.connect(WS_URL, {
      clientId: 'webdash_'+Math.random().toString(16).slice(2),
      clean: true,
      connectTimeout: 8000,
      reconnectPeriod: 2000,
      keepalive: 30,
      resubscribe: true,
    });

    client.on('connect', ()=>{
      els.mqttStatus.textContent = 'połączono';
      subscribeAll();
      renderDiag('subskrypcje OK');
    });

    client.on('reconnect', ()=>{
      reconnectCount++;
      els.mqttStatus.textContent = 'ponowne łączenie…';
      renderDiag();
    });

    client.on('close', ()=>{
      els.mqttStatus.textContent = 'rozłączono';
      renderDiag();
    });

    client.on('offline', ()=>{
      els.mqttStatus.textContent = 'offline';
      renderDiag();
    });

    client.on('end', ()=>{
      els.mqttStatus.textContent = 'zakończono';
      renderDiag();
    });

    client.on('error', (e)=>{
      els.mqttStatus.textContent = 'błąd MQTT (konsola)';
      console.error('MQTT error:', e);
      renderDiag();
    });

    client.on('message', (topic, payload)=>{
      lastMsgAt = Date.now();
      msgCount++;
      renderDiag();

      const val = payload.toString();

      // PUBLIC WIND
      if (topic === TOPIC_WIND_PUBLIC) {
        const v = noteNum(val);
        els.wind.textContent = (v == null) ? "—" : fmt1dec(v);
        setWindCardClass(v);
        return;
      }

      if (matchTopic(topic, TOPICS.kwh))   { const v = noteNum(val); els.kwh.textContent   = (v==null)?"—":fmt1dec(v); return; }
      if (matchTopic(topic, TOPICS.power)) { const v = noteNum(val); els.power.textContent = (v==null)?"—":fmt1dec(v); return; }
      if (matchTopic(topic, TOPICS.soc))   { const v = noteNum(val); els.soc.textContent   = (v==null)?"—":fmt1dec(v); return; }
      if (matchTopic(topic, TOPICS.bat_v)) { const v = noteNum(val); els.bat_v.textContent = (v==null)?"—":fmt1dec(v); return; }
      if (matchTopic(topic, TOPICS.bat_a)) { const v = noteNum(val); els.bat_a.textContent = (v==null)?"—":fmt1dec(v); return; }

      if (matchTopic(topic, TOPICS.brake_state)) {
        const s = String(val).trim().toUpperCase();
        els.brake.textContent = (s==='ON') ? 'Włączony' : 'Wyłączony';
        return;
      }

      if (matchTopic(topic, TOPICS.load_state)) {
        const s = String(val).trim().toUpperCase();
        els.loadState.textContent = (s==='ON') ? 'Włączone' : 'Wyłączone';
        return;
      }
    });
  }

  // Watchdog: jeśli urządzenie publikuje, a strona "stoi", to wymuszamy restart połączenia.
  setInterval(()=>{
    if(!lastMsgAt) return;
    const idleSec = (Date.now() - lastMsgAt) / 1000;
    if(idleSec > WATCHDOG_IDLE_SEC){
      console.warn(`Watchdog: brak wiadomości ${Math.round(idleSec)}s -> restart MQTT`);
      els.mqttStatus.textContent = `watchdog (${Math.round(idleSec)}s) – restart…`;
      renderDiag();
      connect();
    }
  }, 5000);

  // Po powrocie na kartę: wznowienie autoplay + odświeżenie połączenia jeśli trzeba
  document.addEventListener('visibilitychange', ()=>{
    if (!document.hidden){
      document.querySelectorAll('video.bg-video').forEach(v=>{
        if (v && v.paused) v.play().catch(()=>{});
      });
      // jeżeli po powrocie karta była "uśpiona", watchdog zrobi swoje,
      // ale możemy szybciej sprawdzić czy połączenie żyje:
      renderDiag('powrót na kartę');
    }
  });

  setWindCardClass(null);
  renderDiag();
  connect();
})();
</script>

</body>
</html>
